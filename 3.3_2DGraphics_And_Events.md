# 2D-Graphics

## Generating graphics (in Java)

This section looks at how graphics can be used to visualise data. The starting point is the Model-View approach, where the data to be displayed is located in some model data structure or is generated by a thread representing the model. The view is implemented in the Canvas component. Even simple graphical components, such as circles and rectangles, can be used to implement a visualization. This can be used, for example, to represent the flow of customers in a world modelled by a simulator.

### Canvas and graphic contex

Graphics are generated in the `javafx.scene.canvas.Canvas` component. It is a drawing board on which you can draw patterns using the drawing routines of the `javafx.scene.canvas.GraphicsContext` class. The drawing routines select the drawing color and the image to be drawn, e.g:
```Java
private GraphicsContext gc;  // Canvas has only one of these

gc.setFill(Color.YELLOW);    // control the color
gc.fillRect(0, 0, 20, 30);   // shape (rectangle), position (x and y), width and height
```

The canvas is a rectangle and its size can be specified as a parameter of its constructor. The canvas component has no background and it is transparent.

If you want a background color for the Canvas, it can be placed on a self-sized background (Pane) with a color, or, in some cases, it can be filled with a self-sized coloured rectangle.

The graphics context of the Canvas can be obtained with `getGraphicsContext2D()`.

You should define a subclass for Canvas (modularity and MVC); below the Display class inherits the Canvas-class:
```Java
public class Display extends Canvas {
	   private int x = 40;
	   private int y = 60;
	   private GraphicsContext gc;

	   public Naytto(int w, int h) {
	       super(w, h);
	       gc = this.getGraphicsContext2D();
	   }

	   public void drawBall(){
	      gc.setFill(Color.GREEN);
	      gc.fillOval(x, y , 50, 50);
	   }
}
```

### Updating Node objects attached to the Scene objects

Node objects can be built and modified from any thread as long as they are not connected to the Scene. After they are attached to Scene, they may only be processed in the JavaFX Application Thread.

Canvas is a subclass of Node, so it can only be modified (i.e. changed) in the JavaFX thread. The standard TextField components are also Nodes (see [JavaFX API](https://docs.oracle.com/javase/8/javafx/api/toc.htm)). However, there is a `Platform.runLater()` method which can be called from the encoded thread itself, and which can be used to direct a `Runnable` implementer that modifies a Node object to execute on a JavaFX thread, see example below:
```Java
public void run() {   // Own Thread
    while (fRunning) {
        if (Math.random() <= 0.5)
            Platform.runLater(new Runnable() {  // move to JavaFX thread
                 public void run() {
                    display.moveBall(2,0);      // Canvas update
                 }
            });
        else …
```
using Lambdas it can be written as:
```Java
public void run() {   // Own thread
    while (fRunning) {
        if (Math.random() <= 0.5)
            Platform.runLater( () -> naytto.siirraPallo(2,0));  // Canvas update
	…
```
This takes advantage of Java's functional programming feature, where the method call (`display.moveBall(2,0)`) can be passed as such to the method as a parameter instead of an anonymous entity. Works in cases where the anonymous entity (in this case, the thread implementing the `Runnable` interface) has exactly one interface method (i.e., `run()` in this case).

Pallo and Pallo2 examples here!

### Layers of canvas objects

You can create several canvases of the same size (which can be layered), e.g.:
```Java
layer1 = new Canvas(300, 250);
layer2 = new Canvas(300, 250);

gc1 = layer1.getGraphicsContext2D();
gc1.setFill(Color.GREEN);
gc1.fillOval(50, 50, 20, 20);
gc2 = layer2.getGraphicsContext2D();
gc2.setFill(Color.BLUE);
gc2.fillOval(100, 100, 20, 20);
```

Kerroksia example here!

The Canvas objects created separately below are initially attached to the Pane platform, which has no layout, and attached to the middle of the BorderPane platform. It is further connected to the root component, which in this example is the Group component.
```Java
Pane pane = new Pane();
pane.getChildren().add(layer1);
pane.getChildren().add(layer2);
layer1.toFront();   // according to the documents, works only if Node is on Group (cannot verify that)
borderPane.setCenter(pane);
root.getChildren().add(borderPane);
primaryStage.setScene(new Scene(root));
```

## Events


### Mouse events

For example, you can add a mouse event handler to the Canvas layer:
```Java
layer1.addEventHandler( MouseEvent.MOUSE_PRESSED, 
		            new EventHandler<MouseEvent>() {
	@Override
	public void handle(MouseEvent e) {
		gc1.fillOval(e.getX(), e.getY(), 20, 20);
	}
});
```
This is the processing of an event in an anonymous inner class. `MouseEvent` contains, among other things, information about the location where the mouse was clicked (x and y).

### ChoiceBox

```Java
private void createChoiceBox() {
	cb = new ChoiceBox<String>();
	cb.setItems(FXCollections.observableArrayList("Layer 1 is GREEN",  "Layer 2 is BLUE"));
	cb.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<Object>() {
		@Override
		public void changed(ObservableValue<?> o, Object o1, Object o2) {
			if (o2.toString().equals("Layer 1 is GREEN")) {
				layer1.toFront();
			} else if (o2.toString().equals("Layer 2 is BLUE")) {
				layer2.toFront();
			}	
		}
	});
	cb.setValue("Layer 1 is GREEN");
}
```

## SceneBuilder and animation Canvas

In the JavaFX program discussed in this lesson, the animation window is the Visualization class, which inherits from the Canvas class.

If you are using SceneBuilder, one way to do this is as follows:

The fxml definition is done for the Canvas class (not the Visualization class).

In the Documents/Code Base... folder there is an example Animation.zip where this is done.

The basic idea is that Visualization does not inherit from Canvas, but Visualization refers to Canvas, which is placed as a Canvas node in the UI.

The thread in PanelsController in the example represents the Engine thread in the simulator, where the visualization calls come from.